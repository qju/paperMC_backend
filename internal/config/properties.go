package config

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

const fileName string = "server.properties"

func LoadProperties(path string) (map[string]string, error) {
	fullPath := filepath.Join(path, fileName)
	fi, err := os.Open(fullPath)

	if err != nil {
		return nil, err
	}
	defer fi.Close()

	props := make(map[string]string)
	scanner := bufio.NewScanner(fi)
	// scanner.Split("=")
	for scanner.Scan() {
		// Save the read line and clean it
		line := scanner.Text()
		clean_line := strings.TrimSpace(line)

		// check if comment or empty string, if so continue
		if clean_line == "" || strings.HasPrefix(clean_line, "#") {
			continue
		}

		// split line in to property and value
		parts := strings.SplitN(clean_line, "=", 2)
		if len(parts) != 2 {
			continue
		}
		props[parts[0]] = parts[1]
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}
	return props, nil
}

func SavePropertiesSimple(path string, props map[string]string) error {

	fullPath := filepath.Join(path, fileName)
	// 1. Create file (truncate it if exists)
	file, err := os.Create(fullPath)
	if err != nil {
		return err
	}
	defer file.Close()

	// 2. Extract keys to a slice
	keys := make([]string, 0, len(props))
	for k := range props {
		keys = append(keys, k)
	}

	// 3. Sort keys (deterministic output)
	sort.Strings(keys)

	// 4. Write loop
	// but first write the header line to let user know who generated the file
	file.WriteString("# Generated by PaperMC Manager\n")
	for _, k := range keys {
		line := fmt.Sprintf("%s=%s\n", k, props[k])
		if _, err := file.WriteString(line); err != nil {
			return err
		}
	}
	return nil
}

func SaveProperties(path string, changes map[string]string) error {
	fullPath := filepath.Join(path, fileName)

	// 1. Read the WHOLE original file
	// We need the original content to preserve comments
	input, err := os.ReadFile(fullPath)
	if err != nil {
		// if file doesn't exist, just create a fresh (fallback to simple write)
		if os.IsNotExist(err) {
			return SavePropertiesSimple(fullPath, changes)
		}
		return err

	}

	var output bytes.Buffer

	// Track which keys we have processed so we can add NEW once at the end
	processedKeys := make(map[string]bool)

	scanner := bufio.NewScanner(bytes.NewReader(input))
	for scanner.Scan() {
		line := scanner.Text()
		clean_line := strings.TrimSpace(line)
		if clean_line == "" || strings.HasPrefix(clean_line, "#") {
			output.WriteString(line + "\n")
			continue
		}

		// split line in to property and value
		parts := strings.SplitN(clean_line, "=", 2)

		if len(parts) == 2 {
			key := parts[0]
			if newValue, exists := changes[key]; exists {
				output.WriteString(fmt.Sprintf("%s=%s\n", key, newValue))
				processedKeys[key] = true //  Mark done
				continue
			}
		}
		// If the line was not a comment, empty, or a changed key, write the original line back
		output.WriteString(line + "\n")
	}

	// 2. Extract keys to a slice
	keys := make([]string, 0, len(changes))
	for k := range changes {
		keys = append(keys, k)
	}

	// 3. Sort keys (deterministic output)
	sort.Strings(keys)
	for _, key := range keys {
		if !processedKeys[key] {
			output.WriteString(fmt.Sprintf("%s=%s\n", key, changes[key]))
		}
	}
	// Write everything back to disk
	return os.WriteFile(fullPath, output.Bytes(), 0644)
}
